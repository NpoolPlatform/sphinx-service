// Code generated by entc, DO NOT EDIT.

package transaction

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/NpoolPlatform/sphinx-service/pkg/db/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int32) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int32) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int32) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int32) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int32) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int32) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int32) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int32) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int32) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// AmountUint64 applies equality check predicate on the "amount_uint64" field. It's identical to AmountUint64EQ.
func AmountUint64(v uint64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmountUint64), v))
	})
}

// AmountFloat64 applies equality check predicate on the "amount_float64" field. It's identical to AmountFloat64EQ.
func AmountFloat64(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmountFloat64), v))
	})
}

// AddressFrom applies equality check predicate on the "address_from" field. It's identical to AddressFromEQ.
func AddressFrom(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAddressFrom), v))
	})
}

// AddressTo applies equality check predicate on the "address_to" field. It's identical to AddressToEQ.
func AddressTo(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAddressTo), v))
	})
}

// NeedManualReview applies equality check predicate on the "need_manual_review" field. It's identical to NeedManualReviewEQ.
func NeedManualReview(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNeedManualReview), v))
	})
}

// TransactionIDInsite applies equality check predicate on the "transaction_id_insite" field. It's identical to TransactionIDInsiteEQ.
func TransactionIDInsite(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDChain applies equality check predicate on the "transaction_id_chain" field. It's identical to TransactionIDChainEQ.
func TransactionIDChain(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionIDChain), v))
	})
}

// Mutex applies equality check predicate on the "mutex" field. It's identical to MutexEQ.
func Mutex(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMutex), v))
	})
}

// SignatureUser applies equality check predicate on the "signature_user" field. It's identical to SignatureUserEQ.
func SignatureUser(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSignatureUser), v))
	})
}

// SignaturePlatform applies equality check predicate on the "signature_platform" field. It's identical to SignaturePlatformEQ.
func SignaturePlatform(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSignaturePlatform), v))
	})
}

// CreatetimeUtc applies equality check predicate on the "createtime_utc" field. It's identical to CreatetimeUtcEQ.
func CreatetimeUtc(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatetimeUtc), v))
	})
}

// UpdatetimeUtc applies equality check predicate on the "updatetime_utc" field. It's identical to UpdatetimeUtcEQ.
func UpdatetimeUtc(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatetimeUtc), v))
	})
}

// AmountUint64EQ applies the EQ predicate on the "amount_uint64" field.
func AmountUint64EQ(v uint64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmountUint64), v))
	})
}

// AmountUint64NEQ applies the NEQ predicate on the "amount_uint64" field.
func AmountUint64NEQ(v uint64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAmountUint64), v))
	})
}

// AmountUint64In applies the In predicate on the "amount_uint64" field.
func AmountUint64In(vs ...uint64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAmountUint64), v...))
	})
}

// AmountUint64NotIn applies the NotIn predicate on the "amount_uint64" field.
func AmountUint64NotIn(vs ...uint64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAmountUint64), v...))
	})
}

// AmountUint64GT applies the GT predicate on the "amount_uint64" field.
func AmountUint64GT(v uint64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAmountUint64), v))
	})
}

// AmountUint64GTE applies the GTE predicate on the "amount_uint64" field.
func AmountUint64GTE(v uint64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAmountUint64), v))
	})
}

// AmountUint64LT applies the LT predicate on the "amount_uint64" field.
func AmountUint64LT(v uint64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAmountUint64), v))
	})
}

// AmountUint64LTE applies the LTE predicate on the "amount_uint64" field.
func AmountUint64LTE(v uint64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAmountUint64), v))
	})
}

// AmountFloat64EQ applies the EQ predicate on the "amount_float64" field.
func AmountFloat64EQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmountFloat64), v))
	})
}

// AmountFloat64NEQ applies the NEQ predicate on the "amount_float64" field.
func AmountFloat64NEQ(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAmountFloat64), v))
	})
}

// AmountFloat64In applies the In predicate on the "amount_float64" field.
func AmountFloat64In(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAmountFloat64), v...))
	})
}

// AmountFloat64NotIn applies the NotIn predicate on the "amount_float64" field.
func AmountFloat64NotIn(vs ...float64) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAmountFloat64), v...))
	})
}

// AmountFloat64GT applies the GT predicate on the "amount_float64" field.
func AmountFloat64GT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAmountFloat64), v))
	})
}

// AmountFloat64GTE applies the GTE predicate on the "amount_float64" field.
func AmountFloat64GTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAmountFloat64), v))
	})
}

// AmountFloat64LT applies the LT predicate on the "amount_float64" field.
func AmountFloat64LT(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAmountFloat64), v))
	})
}

// AmountFloat64LTE applies the LTE predicate on the "amount_float64" field.
func AmountFloat64LTE(v float64) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAmountFloat64), v))
	})
}

// AddressFromEQ applies the EQ predicate on the "address_from" field.
func AddressFromEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAddressFrom), v))
	})
}

// AddressFromNEQ applies the NEQ predicate on the "address_from" field.
func AddressFromNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAddressFrom), v))
	})
}

// AddressFromIn applies the In predicate on the "address_from" field.
func AddressFromIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAddressFrom), v...))
	})
}

// AddressFromNotIn applies the NotIn predicate on the "address_from" field.
func AddressFromNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAddressFrom), v...))
	})
}

// AddressFromGT applies the GT predicate on the "address_from" field.
func AddressFromGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAddressFrom), v))
	})
}

// AddressFromGTE applies the GTE predicate on the "address_from" field.
func AddressFromGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAddressFrom), v))
	})
}

// AddressFromLT applies the LT predicate on the "address_from" field.
func AddressFromLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAddressFrom), v))
	})
}

// AddressFromLTE applies the LTE predicate on the "address_from" field.
func AddressFromLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAddressFrom), v))
	})
}

// AddressFromContains applies the Contains predicate on the "address_from" field.
func AddressFromContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAddressFrom), v))
	})
}

// AddressFromHasPrefix applies the HasPrefix predicate on the "address_from" field.
func AddressFromHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAddressFrom), v))
	})
}

// AddressFromHasSuffix applies the HasSuffix predicate on the "address_from" field.
func AddressFromHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAddressFrom), v))
	})
}

// AddressFromEqualFold applies the EqualFold predicate on the "address_from" field.
func AddressFromEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAddressFrom), v))
	})
}

// AddressFromContainsFold applies the ContainsFold predicate on the "address_from" field.
func AddressFromContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAddressFrom), v))
	})
}

// AddressToEQ applies the EQ predicate on the "address_to" field.
func AddressToEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAddressTo), v))
	})
}

// AddressToNEQ applies the NEQ predicate on the "address_to" field.
func AddressToNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAddressTo), v))
	})
}

// AddressToIn applies the In predicate on the "address_to" field.
func AddressToIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAddressTo), v...))
	})
}

// AddressToNotIn applies the NotIn predicate on the "address_to" field.
func AddressToNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAddressTo), v...))
	})
}

// AddressToGT applies the GT predicate on the "address_to" field.
func AddressToGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAddressTo), v))
	})
}

// AddressToGTE applies the GTE predicate on the "address_to" field.
func AddressToGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAddressTo), v))
	})
}

// AddressToLT applies the LT predicate on the "address_to" field.
func AddressToLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAddressTo), v))
	})
}

// AddressToLTE applies the LTE predicate on the "address_to" field.
func AddressToLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAddressTo), v))
	})
}

// AddressToContains applies the Contains predicate on the "address_to" field.
func AddressToContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAddressTo), v))
	})
}

// AddressToHasPrefix applies the HasPrefix predicate on the "address_to" field.
func AddressToHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAddressTo), v))
	})
}

// AddressToHasSuffix applies the HasSuffix predicate on the "address_to" field.
func AddressToHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAddressTo), v))
	})
}

// AddressToEqualFold applies the EqualFold predicate on the "address_to" field.
func AddressToEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAddressTo), v))
	})
}

// AddressToContainsFold applies the ContainsFold predicate on the "address_to" field.
func AddressToContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAddressTo), v))
	})
}

// NeedManualReviewEQ applies the EQ predicate on the "need_manual_review" field.
func NeedManualReviewEQ(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNeedManualReview), v))
	})
}

// NeedManualReviewNEQ applies the NEQ predicate on the "need_manual_review" field.
func NeedManualReviewNEQ(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldNeedManualReview), v))
	})
}

// TypeEQ applies the EQ predicate on the "type" field.
func TypeEQ(v Type) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldType), v))
	})
}

// TypeNEQ applies the NEQ predicate on the "type" field.
func TypeNEQ(v Type) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldType), v))
	})
}

// TypeIn applies the In predicate on the "type" field.
func TypeIn(vs ...Type) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldType), v...))
	})
}

// TypeNotIn applies the NotIn predicate on the "type" field.
func TypeNotIn(vs ...Type) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldType), v...))
	})
}

// TransactionIDInsiteEQ applies the EQ predicate on the "transaction_id_insite" field.
func TransactionIDInsiteEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDInsiteNEQ applies the NEQ predicate on the "transaction_id_insite" field.
func TransactionIDInsiteNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDInsiteIn applies the In predicate on the "transaction_id_insite" field.
func TransactionIDInsiteIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTransactionIDInsite), v...))
	})
}

// TransactionIDInsiteNotIn applies the NotIn predicate on the "transaction_id_insite" field.
func TransactionIDInsiteNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTransactionIDInsite), v...))
	})
}

// TransactionIDInsiteGT applies the GT predicate on the "transaction_id_insite" field.
func TransactionIDInsiteGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDInsiteGTE applies the GTE predicate on the "transaction_id_insite" field.
func TransactionIDInsiteGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDInsiteLT applies the LT predicate on the "transaction_id_insite" field.
func TransactionIDInsiteLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDInsiteLTE applies the LTE predicate on the "transaction_id_insite" field.
func TransactionIDInsiteLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDInsiteContains applies the Contains predicate on the "transaction_id_insite" field.
func TransactionIDInsiteContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDInsiteHasPrefix applies the HasPrefix predicate on the "transaction_id_insite" field.
func TransactionIDInsiteHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDInsiteHasSuffix applies the HasSuffix predicate on the "transaction_id_insite" field.
func TransactionIDInsiteHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDInsiteEqualFold applies the EqualFold predicate on the "transaction_id_insite" field.
func TransactionIDInsiteEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDInsiteContainsFold applies the ContainsFold predicate on the "transaction_id_insite" field.
func TransactionIDInsiteContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTransactionIDInsite), v))
	})
}

// TransactionIDChainEQ applies the EQ predicate on the "transaction_id_chain" field.
func TransactionIDChainEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionIDChain), v))
	})
}

// TransactionIDChainNEQ applies the NEQ predicate on the "transaction_id_chain" field.
func TransactionIDChainNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTransactionIDChain), v))
	})
}

// TransactionIDChainIn applies the In predicate on the "transaction_id_chain" field.
func TransactionIDChainIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTransactionIDChain), v...))
	})
}

// TransactionIDChainNotIn applies the NotIn predicate on the "transaction_id_chain" field.
func TransactionIDChainNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTransactionIDChain), v...))
	})
}

// TransactionIDChainGT applies the GT predicate on the "transaction_id_chain" field.
func TransactionIDChainGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTransactionIDChain), v))
	})
}

// TransactionIDChainGTE applies the GTE predicate on the "transaction_id_chain" field.
func TransactionIDChainGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTransactionIDChain), v))
	})
}

// TransactionIDChainLT applies the LT predicate on the "transaction_id_chain" field.
func TransactionIDChainLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTransactionIDChain), v))
	})
}

// TransactionIDChainLTE applies the LTE predicate on the "transaction_id_chain" field.
func TransactionIDChainLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTransactionIDChain), v))
	})
}

// TransactionIDChainContains applies the Contains predicate on the "transaction_id_chain" field.
func TransactionIDChainContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTransactionIDChain), v))
	})
}

// TransactionIDChainHasPrefix applies the HasPrefix predicate on the "transaction_id_chain" field.
func TransactionIDChainHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTransactionIDChain), v))
	})
}

// TransactionIDChainHasSuffix applies the HasSuffix predicate on the "transaction_id_chain" field.
func TransactionIDChainHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTransactionIDChain), v))
	})
}

// TransactionIDChainEqualFold applies the EqualFold predicate on the "transaction_id_chain" field.
func TransactionIDChainEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTransactionIDChain), v))
	})
}

// TransactionIDChainContainsFold applies the ContainsFold predicate on the "transaction_id_chain" field.
func TransactionIDChainContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTransactionIDChain), v))
	})
}

// StatusEQ applies the EQ predicate on the "status" field.
func StatusEQ(v Status) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// StatusNEQ applies the NEQ predicate on the "status" field.
func StatusNEQ(v Status) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatus), v))
	})
}

// StatusIn applies the In predicate on the "status" field.
func StatusIn(vs ...Status) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStatus), v...))
	})
}

// StatusNotIn applies the NotIn predicate on the "status" field.
func StatusNotIn(vs ...Status) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStatus), v...))
	})
}

// MutexEQ applies the EQ predicate on the "mutex" field.
func MutexEQ(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMutex), v))
	})
}

// MutexNEQ applies the NEQ predicate on the "mutex" field.
func MutexNEQ(v bool) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMutex), v))
	})
}

// SignatureUserEQ applies the EQ predicate on the "signature_user" field.
func SignatureUserEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSignatureUser), v))
	})
}

// SignatureUserNEQ applies the NEQ predicate on the "signature_user" field.
func SignatureUserNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSignatureUser), v))
	})
}

// SignatureUserIn applies the In predicate on the "signature_user" field.
func SignatureUserIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSignatureUser), v...))
	})
}

// SignatureUserNotIn applies the NotIn predicate on the "signature_user" field.
func SignatureUserNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSignatureUser), v...))
	})
}

// SignatureUserGT applies the GT predicate on the "signature_user" field.
func SignatureUserGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSignatureUser), v))
	})
}

// SignatureUserGTE applies the GTE predicate on the "signature_user" field.
func SignatureUserGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSignatureUser), v))
	})
}

// SignatureUserLT applies the LT predicate on the "signature_user" field.
func SignatureUserLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSignatureUser), v))
	})
}

// SignatureUserLTE applies the LTE predicate on the "signature_user" field.
func SignatureUserLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSignatureUser), v))
	})
}

// SignatureUserContains applies the Contains predicate on the "signature_user" field.
func SignatureUserContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSignatureUser), v))
	})
}

// SignatureUserHasPrefix applies the HasPrefix predicate on the "signature_user" field.
func SignatureUserHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSignatureUser), v))
	})
}

// SignatureUserHasSuffix applies the HasSuffix predicate on the "signature_user" field.
func SignatureUserHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSignatureUser), v))
	})
}

// SignatureUserEqualFold applies the EqualFold predicate on the "signature_user" field.
func SignatureUserEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSignatureUser), v))
	})
}

// SignatureUserContainsFold applies the ContainsFold predicate on the "signature_user" field.
func SignatureUserContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSignatureUser), v))
	})
}

// SignaturePlatformEQ applies the EQ predicate on the "signature_platform" field.
func SignaturePlatformEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSignaturePlatform), v))
	})
}

// SignaturePlatformNEQ applies the NEQ predicate on the "signature_platform" field.
func SignaturePlatformNEQ(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSignaturePlatform), v))
	})
}

// SignaturePlatformIn applies the In predicate on the "signature_platform" field.
func SignaturePlatformIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSignaturePlatform), v...))
	})
}

// SignaturePlatformNotIn applies the NotIn predicate on the "signature_platform" field.
func SignaturePlatformNotIn(vs ...string) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSignaturePlatform), v...))
	})
}

// SignaturePlatformGT applies the GT predicate on the "signature_platform" field.
func SignaturePlatformGT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSignaturePlatform), v))
	})
}

// SignaturePlatformGTE applies the GTE predicate on the "signature_platform" field.
func SignaturePlatformGTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSignaturePlatform), v))
	})
}

// SignaturePlatformLT applies the LT predicate on the "signature_platform" field.
func SignaturePlatformLT(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSignaturePlatform), v))
	})
}

// SignaturePlatformLTE applies the LTE predicate on the "signature_platform" field.
func SignaturePlatformLTE(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSignaturePlatform), v))
	})
}

// SignaturePlatformContains applies the Contains predicate on the "signature_platform" field.
func SignaturePlatformContains(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSignaturePlatform), v))
	})
}

// SignaturePlatformHasPrefix applies the HasPrefix predicate on the "signature_platform" field.
func SignaturePlatformHasPrefix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSignaturePlatform), v))
	})
}

// SignaturePlatformHasSuffix applies the HasSuffix predicate on the "signature_platform" field.
func SignaturePlatformHasSuffix(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSignaturePlatform), v))
	})
}

// SignaturePlatformEqualFold applies the EqualFold predicate on the "signature_platform" field.
func SignaturePlatformEqualFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSignaturePlatform), v))
	})
}

// SignaturePlatformContainsFold applies the ContainsFold predicate on the "signature_platform" field.
func SignaturePlatformContainsFold(v string) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSignaturePlatform), v))
	})
}

// CreatetimeUtcEQ applies the EQ predicate on the "createtime_utc" field.
func CreatetimeUtcEQ(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatetimeUtc), v))
	})
}

// CreatetimeUtcNEQ applies the NEQ predicate on the "createtime_utc" field.
func CreatetimeUtcNEQ(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatetimeUtc), v))
	})
}

// CreatetimeUtcIn applies the In predicate on the "createtime_utc" field.
func CreatetimeUtcIn(vs ...int) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatetimeUtc), v...))
	})
}

// CreatetimeUtcNotIn applies the NotIn predicate on the "createtime_utc" field.
func CreatetimeUtcNotIn(vs ...int) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatetimeUtc), v...))
	})
}

// CreatetimeUtcGT applies the GT predicate on the "createtime_utc" field.
func CreatetimeUtcGT(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatetimeUtc), v))
	})
}

// CreatetimeUtcGTE applies the GTE predicate on the "createtime_utc" field.
func CreatetimeUtcGTE(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatetimeUtc), v))
	})
}

// CreatetimeUtcLT applies the LT predicate on the "createtime_utc" field.
func CreatetimeUtcLT(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatetimeUtc), v))
	})
}

// CreatetimeUtcLTE applies the LTE predicate on the "createtime_utc" field.
func CreatetimeUtcLTE(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatetimeUtc), v))
	})
}

// UpdatetimeUtcEQ applies the EQ predicate on the "updatetime_utc" field.
func UpdatetimeUtcEQ(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdatetimeUtc), v))
	})
}

// UpdatetimeUtcNEQ applies the NEQ predicate on the "updatetime_utc" field.
func UpdatetimeUtcNEQ(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdatetimeUtc), v))
	})
}

// UpdatetimeUtcIn applies the In predicate on the "updatetime_utc" field.
func UpdatetimeUtcIn(vs ...int) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdatetimeUtc), v...))
	})
}

// UpdatetimeUtcNotIn applies the NotIn predicate on the "updatetime_utc" field.
func UpdatetimeUtcNotIn(vs ...int) predicate.Transaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Transaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdatetimeUtc), v...))
	})
}

// UpdatetimeUtcGT applies the GT predicate on the "updatetime_utc" field.
func UpdatetimeUtcGT(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdatetimeUtc), v))
	})
}

// UpdatetimeUtcGTE applies the GTE predicate on the "updatetime_utc" field.
func UpdatetimeUtcGTE(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdatetimeUtc), v))
	})
}

// UpdatetimeUtcLT applies the LT predicate on the "updatetime_utc" field.
func UpdatetimeUtcLT(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdatetimeUtc), v))
	})
}

// UpdatetimeUtcLTE applies the LTE predicate on the "updatetime_utc" field.
func UpdatetimeUtcLTE(v int) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdatetimeUtc), v))
	})
}

// HasCoin applies the HasEdge predicate on the "coin" edge.
func HasCoin() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CoinTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, CoinTable, CoinColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCoinWith applies the HasEdge predicate on the "coin" edge with a given conditions (other predicates).
func HasCoinWith(preds ...predicate.CoinInfo) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CoinInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, CoinTable, CoinColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasReview applies the HasEdge predicate on the "review" edge.
func HasReview() predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ReviewTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ReviewTable, ReviewColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasReviewWith applies the HasEdge predicate on the "review" edge with a given conditions (other predicates).
func HasReviewWith(preds ...predicate.Review) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ReviewInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ReviewTable, ReviewColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Transaction) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Transaction) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Transaction) predicate.Transaction {
	return predicate.Transaction(func(s *sql.Selector) {
		p(s.Not())
	})
}
