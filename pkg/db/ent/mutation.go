// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/sphinx-service/pkg/db/ent/coininfo"
	"github.com/NpoolPlatform/sphinx-service/pkg/db/ent/keystore"
	"github.com/NpoolPlatform/sphinx-service/pkg/db/ent/predicate"
	"github.com/NpoolPlatform/sphinx-service/pkg/db/ent/review"
	"github.com/NpoolPlatform/sphinx-service/pkg/db/ent/transaction"
	"github.com/NpoolPlatform/sphinx-service/pkg/db/ent/walletnode"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCoinInfo    = "CoinInfo"
	TypeKeyStore    = "KeyStore"
	TypeReview      = "Review"
	TypeTransaction = "Transaction"
	TypeWalletNode  = "WalletNode"
)

// CoinInfoMutation represents an operation that mutates the CoinInfo nodes in the graph.
type CoinInfoMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	unit                *string
	need_signinfo       *bool
	clearedFields       map[string]struct{}
	keys                map[int]struct{}
	removedkeys         map[int]struct{}
	clearedkeys         bool
	transactions        map[int]struct{}
	removedtransactions map[int]struct{}
	clearedtransactions bool
	reviews             map[int]struct{}
	removedreviews      map[int]struct{}
	clearedreviews      bool
	wallet_nodes        map[int]struct{}
	removedwallet_nodes map[int]struct{}
	clearedwallet_nodes bool
	done                bool
	oldValue            func(context.Context) (*CoinInfo, error)
	predicates          []predicate.CoinInfo
}

var _ ent.Mutation = (*CoinInfoMutation)(nil)

// coininfoOption allows management of the mutation configuration using functional options.
type coininfoOption func(*CoinInfoMutation)

// newCoinInfoMutation creates new mutation for the CoinInfo entity.
func newCoinInfoMutation(c config, op Op, opts ...coininfoOption) *CoinInfoMutation {
	m := &CoinInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeCoinInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCoinInfoID sets the ID field of the mutation.
func withCoinInfoID(id int) coininfoOption {
	return func(m *CoinInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *CoinInfo
		)
		m.oldValue = func(ctx context.Context) (*CoinInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CoinInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoinInfo sets the old CoinInfo of the mutation.
func withCoinInfo(node *CoinInfo) coininfoOption {
	return func(m *CoinInfoMutation) {
		m.oldValue = func(context.Context) (*CoinInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CoinInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CoinInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CoinInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *CoinInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CoinInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CoinInfo entity.
// If the CoinInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CoinInfoMutation) ResetName() {
	m.name = nil
}

// SetUnit sets the "unit" field.
func (m *CoinInfoMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *CoinInfoMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the CoinInfo entity.
// If the CoinInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinInfoMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *CoinInfoMutation) ResetUnit() {
	m.unit = nil
}

// SetNeedSigninfo sets the "need_signinfo" field.
func (m *CoinInfoMutation) SetNeedSigninfo(b bool) {
	m.need_signinfo = &b
}

// NeedSigninfo returns the value of the "need_signinfo" field in the mutation.
func (m *CoinInfoMutation) NeedSigninfo() (r bool, exists bool) {
	v := m.need_signinfo
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedSigninfo returns the old "need_signinfo" field's value of the CoinInfo entity.
// If the CoinInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinInfoMutation) OldNeedSigninfo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNeedSigninfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNeedSigninfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedSigninfo: %w", err)
	}
	return oldValue.NeedSigninfo, nil
}

// ResetNeedSigninfo resets all changes to the "need_signinfo" field.
func (m *CoinInfoMutation) ResetNeedSigninfo() {
	m.need_signinfo = nil
}

// AddKeyIDs adds the "keys" edge to the KeyStore entity by ids.
func (m *CoinInfoMutation) AddKeyIDs(ids ...int) {
	if m.keys == nil {
		m.keys = make(map[int]struct{})
	}
	for i := range ids {
		m.keys[ids[i]] = struct{}{}
	}
}

// ClearKeys clears the "keys" edge to the KeyStore entity.
func (m *CoinInfoMutation) ClearKeys() {
	m.clearedkeys = true
}

// KeysCleared reports if the "keys" edge to the KeyStore entity was cleared.
func (m *CoinInfoMutation) KeysCleared() bool {
	return m.clearedkeys
}

// RemoveKeyIDs removes the "keys" edge to the KeyStore entity by IDs.
func (m *CoinInfoMutation) RemoveKeyIDs(ids ...int) {
	if m.removedkeys == nil {
		m.removedkeys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.keys, ids[i])
		m.removedkeys[ids[i]] = struct{}{}
	}
}

// RemovedKeys returns the removed IDs of the "keys" edge to the KeyStore entity.
func (m *CoinInfoMutation) RemovedKeysIDs() (ids []int) {
	for id := range m.removedkeys {
		ids = append(ids, id)
	}
	return
}

// KeysIDs returns the "keys" edge IDs in the mutation.
func (m *CoinInfoMutation) KeysIDs() (ids []int) {
	for id := range m.keys {
		ids = append(ids, id)
	}
	return
}

// ResetKeys resets all changes to the "keys" edge.
func (m *CoinInfoMutation) ResetKeys() {
	m.keys = nil
	m.clearedkeys = false
	m.removedkeys = nil
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by ids.
func (m *CoinInfoMutation) AddTransactionIDs(ids ...int) {
	if m.transactions == nil {
		m.transactions = make(map[int]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the Transaction entity.
func (m *CoinInfoMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the Transaction entity was cleared.
func (m *CoinInfoMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the Transaction entity by IDs.
func (m *CoinInfoMutation) RemoveTransactionIDs(ids ...int) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the Transaction entity.
func (m *CoinInfoMutation) RemovedTransactionsIDs() (ids []int) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *CoinInfoMutation) TransactionsIDs() (ids []int) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *CoinInfoMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// AddReviewIDs adds the "reviews" edge to the Review entity by ids.
func (m *CoinInfoMutation) AddReviewIDs(ids ...int) {
	if m.reviews == nil {
		m.reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the Review entity.
func (m *CoinInfoMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the Review entity was cleared.
func (m *CoinInfoMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the Review entity by IDs.
func (m *CoinInfoMutation) RemoveReviewIDs(ids ...int) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the Review entity.
func (m *CoinInfoMutation) RemovedReviewsIDs() (ids []int) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *CoinInfoMutation) ReviewsIDs() (ids []int) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *CoinInfoMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddWalletNodeIDs adds the "wallet_nodes" edge to the WalletNode entity by ids.
func (m *CoinInfoMutation) AddWalletNodeIDs(ids ...int) {
	if m.wallet_nodes == nil {
		m.wallet_nodes = make(map[int]struct{})
	}
	for i := range ids {
		m.wallet_nodes[ids[i]] = struct{}{}
	}
}

// ClearWalletNodes clears the "wallet_nodes" edge to the WalletNode entity.
func (m *CoinInfoMutation) ClearWalletNodes() {
	m.clearedwallet_nodes = true
}

// WalletNodesCleared reports if the "wallet_nodes" edge to the WalletNode entity was cleared.
func (m *CoinInfoMutation) WalletNodesCleared() bool {
	return m.clearedwallet_nodes
}

// RemoveWalletNodeIDs removes the "wallet_nodes" edge to the WalletNode entity by IDs.
func (m *CoinInfoMutation) RemoveWalletNodeIDs(ids ...int) {
	if m.removedwallet_nodes == nil {
		m.removedwallet_nodes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.wallet_nodes, ids[i])
		m.removedwallet_nodes[ids[i]] = struct{}{}
	}
}

// RemovedWalletNodes returns the removed IDs of the "wallet_nodes" edge to the WalletNode entity.
func (m *CoinInfoMutation) RemovedWalletNodesIDs() (ids []int) {
	for id := range m.removedwallet_nodes {
		ids = append(ids, id)
	}
	return
}

// WalletNodesIDs returns the "wallet_nodes" edge IDs in the mutation.
func (m *CoinInfoMutation) WalletNodesIDs() (ids []int) {
	for id := range m.wallet_nodes {
		ids = append(ids, id)
	}
	return
}

// ResetWalletNodes resets all changes to the "wallet_nodes" edge.
func (m *CoinInfoMutation) ResetWalletNodes() {
	m.wallet_nodes = nil
	m.clearedwallet_nodes = false
	m.removedwallet_nodes = nil
}

// Where appends a list predicates to the CoinInfoMutation builder.
func (m *CoinInfoMutation) Where(ps ...predicate.CoinInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CoinInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CoinInfo).
func (m *CoinInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CoinInfoMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, coininfo.FieldName)
	}
	if m.unit != nil {
		fields = append(fields, coininfo.FieldUnit)
	}
	if m.need_signinfo != nil {
		fields = append(fields, coininfo.FieldNeedSigninfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CoinInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coininfo.FieldName:
		return m.Name()
	case coininfo.FieldUnit:
		return m.Unit()
	case coininfo.FieldNeedSigninfo:
		return m.NeedSigninfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CoinInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coininfo.FieldName:
		return m.OldName(ctx)
	case coininfo.FieldUnit:
		return m.OldUnit(ctx)
	case coininfo.FieldNeedSigninfo:
		return m.OldNeedSigninfo(ctx)
	}
	return nil, fmt.Errorf("unknown CoinInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coininfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coininfo.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case coininfo.FieldNeedSigninfo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedSigninfo(v)
		return nil
	}
	return fmt.Errorf("unknown CoinInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CoinInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CoinInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CoinInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CoinInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CoinInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CoinInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CoinInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CoinInfoMutation) ResetField(name string) error {
	switch name {
	case coininfo.FieldName:
		m.ResetName()
		return nil
	case coininfo.FieldUnit:
		m.ResetUnit()
		return nil
	case coininfo.FieldNeedSigninfo:
		m.ResetNeedSigninfo()
		return nil
	}
	return fmt.Errorf("unknown CoinInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CoinInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.keys != nil {
		edges = append(edges, coininfo.EdgeKeys)
	}
	if m.transactions != nil {
		edges = append(edges, coininfo.EdgeTransactions)
	}
	if m.reviews != nil {
		edges = append(edges, coininfo.EdgeReviews)
	}
	if m.wallet_nodes != nil {
		edges = append(edges, coininfo.EdgeWalletNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CoinInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coininfo.EdgeKeys:
		ids := make([]ent.Value, 0, len(m.keys))
		for id := range m.keys {
			ids = append(ids, id)
		}
		return ids
	case coininfo.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case coininfo.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case coininfo.EdgeWalletNodes:
		ids := make([]ent.Value, 0, len(m.wallet_nodes))
		for id := range m.wallet_nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CoinInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedkeys != nil {
		edges = append(edges, coininfo.EdgeKeys)
	}
	if m.removedtransactions != nil {
		edges = append(edges, coininfo.EdgeTransactions)
	}
	if m.removedreviews != nil {
		edges = append(edges, coininfo.EdgeReviews)
	}
	if m.removedwallet_nodes != nil {
		edges = append(edges, coininfo.EdgeWalletNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CoinInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case coininfo.EdgeKeys:
		ids := make([]ent.Value, 0, len(m.removedkeys))
		for id := range m.removedkeys {
			ids = append(ids, id)
		}
		return ids
	case coininfo.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	case coininfo.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case coininfo.EdgeWalletNodes:
		ids := make([]ent.Value, 0, len(m.removedwallet_nodes))
		for id := range m.removedwallet_nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CoinInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedkeys {
		edges = append(edges, coininfo.EdgeKeys)
	}
	if m.clearedtransactions {
		edges = append(edges, coininfo.EdgeTransactions)
	}
	if m.clearedreviews {
		edges = append(edges, coininfo.EdgeReviews)
	}
	if m.clearedwallet_nodes {
		edges = append(edges, coininfo.EdgeWalletNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CoinInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case coininfo.EdgeKeys:
		return m.clearedkeys
	case coininfo.EdgeTransactions:
		return m.clearedtransactions
	case coininfo.EdgeReviews:
		return m.clearedreviews
	case coininfo.EdgeWalletNodes:
		return m.clearedwallet_nodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CoinInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CoinInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CoinInfoMutation) ResetEdge(name string) error {
	switch name {
	case coininfo.EdgeKeys:
		m.ResetKeys()
		return nil
	case coininfo.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case coininfo.EdgeReviews:
		m.ResetReviews()
		return nil
	case coininfo.EdgeWalletNodes:
		m.ResetWalletNodes()
		return nil
	}
	return fmt.Errorf("unknown CoinInfo edge %s", name)
}

// KeyStoreMutation represents an operation that mutates the KeyStore nodes in the graph.
type KeyStoreMutation struct {
	config
	op            Op
	typ           string
	id            *int
	address       *string
	private_key   *string
	clearedFields map[string]struct{}
	coin          *int
	clearedcoin   bool
	done          bool
	oldValue      func(context.Context) (*KeyStore, error)
	predicates    []predicate.KeyStore
}

var _ ent.Mutation = (*KeyStoreMutation)(nil)

// keystoreOption allows management of the mutation configuration using functional options.
type keystoreOption func(*KeyStoreMutation)

// newKeyStoreMutation creates new mutation for the KeyStore entity.
func newKeyStoreMutation(c config, op Op, opts ...keystoreOption) *KeyStoreMutation {
	m := &KeyStoreMutation{
		config:        c,
		op:            op,
		typ:           TypeKeyStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeyStoreID sets the ID field of the mutation.
func withKeyStoreID(id int) keystoreOption {
	return func(m *KeyStoreMutation) {
		var (
			err   error
			once  sync.Once
			value *KeyStore
		)
		m.oldValue = func(ctx context.Context) (*KeyStore, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KeyStore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeyStore sets the old KeyStore of the mutation.
func withKeyStore(node *KeyStore) keystoreOption {
	return func(m *KeyStoreMutation) {
		m.oldValue = func(context.Context) (*KeyStore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeyStoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeyStoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeyStoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddress sets the "address" field.
func (m *KeyStoreMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *KeyStoreMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the KeyStore entity.
// If the KeyStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeyStoreMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *KeyStoreMutation) ResetAddress() {
	m.address = nil
}

// SetPrivateKey sets the "private_key" field.
func (m *KeyStoreMutation) SetPrivateKey(s string) {
	m.private_key = &s
}

// PrivateKey returns the value of the "private_key" field in the mutation.
func (m *KeyStoreMutation) PrivateKey() (r string, exists bool) {
	v := m.private_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "private_key" field's value of the KeyStore entity.
// If the KeyStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeyStoreMutation) OldPrivateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ResetPrivateKey resets all changes to the "private_key" field.
func (m *KeyStoreMutation) ResetPrivateKey() {
	m.private_key = nil
}

// SetCoinID sets the "coin" edge to the CoinInfo entity by id.
func (m *KeyStoreMutation) SetCoinID(id int) {
	m.coin = &id
}

// ClearCoin clears the "coin" edge to the CoinInfo entity.
func (m *KeyStoreMutation) ClearCoin() {
	m.clearedcoin = true
}

// CoinCleared reports if the "coin" edge to the CoinInfo entity was cleared.
func (m *KeyStoreMutation) CoinCleared() bool {
	return m.clearedcoin
}

// CoinID returns the "coin" edge ID in the mutation.
func (m *KeyStoreMutation) CoinID() (id int, exists bool) {
	if m.coin != nil {
		return *m.coin, true
	}
	return
}

// CoinIDs returns the "coin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoinID instead. It exists only for internal usage by the builders.
func (m *KeyStoreMutation) CoinIDs() (ids []int) {
	if id := m.coin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoin resets all changes to the "coin" edge.
func (m *KeyStoreMutation) ResetCoin() {
	m.coin = nil
	m.clearedcoin = false
}

// Where appends a list predicates to the KeyStoreMutation builder.
func (m *KeyStoreMutation) Where(ps ...predicate.KeyStore) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *KeyStoreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KeyStore).
func (m *KeyStoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeyStoreMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.address != nil {
		fields = append(fields, keystore.FieldAddress)
	}
	if m.private_key != nil {
		fields = append(fields, keystore.FieldPrivateKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeyStoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case keystore.FieldAddress:
		return m.Address()
	case keystore.FieldPrivateKey:
		return m.PrivateKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeyStoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case keystore.FieldAddress:
		return m.OldAddress(ctx)
	case keystore.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	}
	return nil, fmt.Errorf("unknown KeyStore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeyStoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case keystore.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case keystore.FieldPrivateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	}
	return fmt.Errorf("unknown KeyStore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeyStoreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeyStoreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeyStoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KeyStore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeyStoreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeyStoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeyStoreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KeyStore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeyStoreMutation) ResetField(name string) error {
	switch name {
	case keystore.FieldAddress:
		m.ResetAddress()
		return nil
	case keystore.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	}
	return fmt.Errorf("unknown KeyStore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeyStoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.coin != nil {
		edges = append(edges, keystore.EdgeCoin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeyStoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case keystore.EdgeCoin:
		if id := m.coin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeyStoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeyStoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeyStoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcoin {
		edges = append(edges, keystore.EdgeCoin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeyStoreMutation) EdgeCleared(name string) bool {
	switch name {
	case keystore.EdgeCoin:
		return m.clearedcoin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeyStoreMutation) ClearEdge(name string) error {
	switch name {
	case keystore.EdgeCoin:
		m.ClearCoin()
		return nil
	}
	return fmt.Errorf("unknown KeyStore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeyStoreMutation) ResetEdge(name string) error {
	switch name {
	case keystore.EdgeCoin:
		m.ResetCoin()
		return nil
	}
	return fmt.Errorf("unknown KeyStore edge %s", name)
}

// ReviewMutation represents an operation that mutates the Review nodes in the graph.
type ReviewMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	is_approved        *bool
	operator_note      *string
	createtime_utc     *int
	addcreatetime_utc  *int
	updatetime_utc     *int
	addupdatetime_utc  *int
	clearedFields      map[string]struct{}
	transaction        *int
	clearedtransaction bool
	coin               *int
	clearedcoin        bool
	done               bool
	oldValue           func(context.Context) (*Review, error)
	predicates         []predicate.Review
}

var _ ent.Mutation = (*ReviewMutation)(nil)

// reviewOption allows management of the mutation configuration using functional options.
type reviewOption func(*ReviewMutation)

// newReviewMutation creates new mutation for the Review entity.
func newReviewMutation(c config, op Op, opts ...reviewOption) *ReviewMutation {
	m := &ReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewID sets the ID field of the mutation.
func withReviewID(id int) reviewOption {
	return func(m *ReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Review
		)
		m.oldValue = func(ctx context.Context) (*Review, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Review.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReview sets the old Review of the mutation.
func withReview(node *Review) reviewOption {
	return func(m *ReviewMutation) {
		m.oldValue = func(context.Context) (*Review, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetIsApproved sets the "is_approved" field.
func (m *ReviewMutation) SetIsApproved(b bool) {
	m.is_approved = &b
}

// IsApproved returns the value of the "is_approved" field in the mutation.
func (m *ReviewMutation) IsApproved() (r bool, exists bool) {
	v := m.is_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsApproved returns the old "is_approved" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldIsApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsApproved: %w", err)
	}
	return oldValue.IsApproved, nil
}

// ResetIsApproved resets all changes to the "is_approved" field.
func (m *ReviewMutation) ResetIsApproved() {
	m.is_approved = nil
}

// SetOperatorNote sets the "operator_note" field.
func (m *ReviewMutation) SetOperatorNote(s string) {
	m.operator_note = &s
}

// OperatorNote returns the value of the "operator_note" field in the mutation.
func (m *ReviewMutation) OperatorNote() (r string, exists bool) {
	v := m.operator_note
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorNote returns the old "operator_note" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldOperatorNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperatorNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperatorNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorNote: %w", err)
	}
	return oldValue.OperatorNote, nil
}

// ResetOperatorNote resets all changes to the "operator_note" field.
func (m *ReviewMutation) ResetOperatorNote() {
	m.operator_note = nil
}

// SetCreatetimeUtc sets the "createtime_utc" field.
func (m *ReviewMutation) SetCreatetimeUtc(i int) {
	m.createtime_utc = &i
	m.addcreatetime_utc = nil
}

// CreatetimeUtc returns the value of the "createtime_utc" field in the mutation.
func (m *ReviewMutation) CreatetimeUtc() (r int, exists bool) {
	v := m.createtime_utc
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatetimeUtc returns the old "createtime_utc" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldCreatetimeUtc(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatetimeUtc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatetimeUtc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatetimeUtc: %w", err)
	}
	return oldValue.CreatetimeUtc, nil
}

// AddCreatetimeUtc adds i to the "createtime_utc" field.
func (m *ReviewMutation) AddCreatetimeUtc(i int) {
	if m.addcreatetime_utc != nil {
		*m.addcreatetime_utc += i
	} else {
		m.addcreatetime_utc = &i
	}
}

// AddedCreatetimeUtc returns the value that was added to the "createtime_utc" field in this mutation.
func (m *ReviewMutation) AddedCreatetimeUtc() (r int, exists bool) {
	v := m.addcreatetime_utc
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatetimeUtc resets all changes to the "createtime_utc" field.
func (m *ReviewMutation) ResetCreatetimeUtc() {
	m.createtime_utc = nil
	m.addcreatetime_utc = nil
}

// SetUpdatetimeUtc sets the "updatetime_utc" field.
func (m *ReviewMutation) SetUpdatetimeUtc(i int) {
	m.updatetime_utc = &i
	m.addupdatetime_utc = nil
}

// UpdatetimeUtc returns the value of the "updatetime_utc" field in the mutation.
func (m *ReviewMutation) UpdatetimeUtc() (r int, exists bool) {
	v := m.updatetime_utc
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatetimeUtc returns the old "updatetime_utc" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldUpdatetimeUtc(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatetimeUtc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatetimeUtc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatetimeUtc: %w", err)
	}
	return oldValue.UpdatetimeUtc, nil
}

// AddUpdatetimeUtc adds i to the "updatetime_utc" field.
func (m *ReviewMutation) AddUpdatetimeUtc(i int) {
	if m.addupdatetime_utc != nil {
		*m.addupdatetime_utc += i
	} else {
		m.addupdatetime_utc = &i
	}
}

// AddedUpdatetimeUtc returns the value that was added to the "updatetime_utc" field in this mutation.
func (m *ReviewMutation) AddedUpdatetimeUtc() (r int, exists bool) {
	v := m.addupdatetime_utc
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatetimeUtc resets all changes to the "updatetime_utc" field.
func (m *ReviewMutation) ResetUpdatetimeUtc() {
	m.updatetime_utc = nil
	m.addupdatetime_utc = nil
}

// SetTransactionID sets the "transaction" edge to the Transaction entity by id.
func (m *ReviewMutation) SetTransactionID(id int) {
	m.transaction = &id
}

// ClearTransaction clears the "transaction" edge to the Transaction entity.
func (m *ReviewMutation) ClearTransaction() {
	m.clearedtransaction = true
}

// TransactionCleared reports if the "transaction" edge to the Transaction entity was cleared.
func (m *ReviewMutation) TransactionCleared() bool {
	return m.clearedtransaction
}

// TransactionID returns the "transaction" edge ID in the mutation.
func (m *ReviewMutation) TransactionID() (id int, exists bool) {
	if m.transaction != nil {
		return *m.transaction, true
	}
	return
}

// TransactionIDs returns the "transaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) TransactionIDs() (ids []int) {
	if id := m.transaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransaction resets all changes to the "transaction" edge.
func (m *ReviewMutation) ResetTransaction() {
	m.transaction = nil
	m.clearedtransaction = false
}

// SetCoinID sets the "coin" edge to the CoinInfo entity by id.
func (m *ReviewMutation) SetCoinID(id int) {
	m.coin = &id
}

// ClearCoin clears the "coin" edge to the CoinInfo entity.
func (m *ReviewMutation) ClearCoin() {
	m.clearedcoin = true
}

// CoinCleared reports if the "coin" edge to the CoinInfo entity was cleared.
func (m *ReviewMutation) CoinCleared() bool {
	return m.clearedcoin
}

// CoinID returns the "coin" edge ID in the mutation.
func (m *ReviewMutation) CoinID() (id int, exists bool) {
	if m.coin != nil {
		return *m.coin, true
	}
	return
}

// CoinIDs returns the "coin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoinID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) CoinIDs() (ids []int) {
	if id := m.coin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoin resets all changes to the "coin" edge.
func (m *ReviewMutation) ResetCoin() {
	m.coin = nil
	m.clearedcoin = false
}

// Where appends a list predicates to the ReviewMutation builder.
func (m *ReviewMutation) Where(ps ...predicate.Review) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReviewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Review).
func (m *ReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.is_approved != nil {
		fields = append(fields, review.FieldIsApproved)
	}
	if m.operator_note != nil {
		fields = append(fields, review.FieldOperatorNote)
	}
	if m.createtime_utc != nil {
		fields = append(fields, review.FieldCreatetimeUtc)
	}
	if m.updatetime_utc != nil {
		fields = append(fields, review.FieldUpdatetimeUtc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case review.FieldIsApproved:
		return m.IsApproved()
	case review.FieldOperatorNote:
		return m.OperatorNote()
	case review.FieldCreatetimeUtc:
		return m.CreatetimeUtc()
	case review.FieldUpdatetimeUtc:
		return m.UpdatetimeUtc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case review.FieldIsApproved:
		return m.OldIsApproved(ctx)
	case review.FieldOperatorNote:
		return m.OldOperatorNote(ctx)
	case review.FieldCreatetimeUtc:
		return m.OldCreatetimeUtc(ctx)
	case review.FieldUpdatetimeUtc:
		return m.OldUpdatetimeUtc(ctx)
	}
	return nil, fmt.Errorf("unknown Review field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case review.FieldIsApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsApproved(v)
		return nil
	case review.FieldOperatorNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorNote(v)
		return nil
	case review.FieldCreatetimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatetimeUtc(v)
		return nil
	case review.FieldUpdatetimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatetimeUtc(v)
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewMutation) AddedFields() []string {
	var fields []string
	if m.addcreatetime_utc != nil {
		fields = append(fields, review.FieldCreatetimeUtc)
	}
	if m.addupdatetime_utc != nil {
		fields = append(fields, review.FieldUpdatetimeUtc)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case review.FieldCreatetimeUtc:
		return m.AddedCreatetimeUtc()
	case review.FieldUpdatetimeUtc:
		return m.AddedUpdatetimeUtc()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case review.FieldCreatetimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatetimeUtc(v)
		return nil
	case review.FieldUpdatetimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatetimeUtc(v)
		return nil
	}
	return fmt.Errorf("unknown Review numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Review nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewMutation) ResetField(name string) error {
	switch name {
	case review.FieldIsApproved:
		m.ResetIsApproved()
		return nil
	case review.FieldOperatorNote:
		m.ResetOperatorNote()
		return nil
	case review.FieldCreatetimeUtc:
		m.ResetCreatetimeUtc()
		return nil
	case review.FieldUpdatetimeUtc:
		m.ResetUpdatetimeUtc()
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transaction != nil {
		edges = append(edges, review.EdgeTransaction)
	}
	if m.coin != nil {
		edges = append(edges, review.EdgeCoin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeTransaction:
		if id := m.transaction; id != nil {
			return []ent.Value{*id}
		}
	case review.EdgeCoin:
		if id := m.coin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtransaction {
		edges = append(edges, review.EdgeTransaction)
	}
	if m.clearedcoin {
		edges = append(edges, review.EdgeCoin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case review.EdgeTransaction:
		return m.clearedtransaction
	case review.EdgeCoin:
		return m.clearedcoin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewMutation) ClearEdge(name string) error {
	switch name {
	case review.EdgeTransaction:
		m.ClearTransaction()
		return nil
	case review.EdgeCoin:
		m.ClearCoin()
		return nil
	}
	return fmt.Errorf("unknown Review unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewMutation) ResetEdge(name string) error {
	switch name {
	case review.EdgeTransaction:
		m.ResetTransaction()
		return nil
	case review.EdgeCoin:
		m.ResetCoin()
		return nil
	}
	return fmt.Errorf("unknown Review edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	amount_int            *int
	addamount_int         *int
	amount_digits         *int
	addamount_digits      *int
	address_from          *string
	address_to            *string
	need_manual_review    *bool
	_type                 *transaction.Type
	transaction_id_insite *string
	transaction_id_chain  *string
	status                *transaction.Status
	mutex                 *bool
	createtime_utc        *int
	addcreatetime_utc     *int
	updatetime_utc        *int
	addupdatetime_utc     *int
	clearedFields         map[string]struct{}
	coin                  *int
	clearedcoin           bool
	review                map[int]struct{}
	removedreview         map[int]struct{}
	clearedreview         bool
	done                  bool
	oldValue              func(context.Context) (*Transaction, error)
	predicates            []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAmountInt sets the "amount_int" field.
func (m *TransactionMutation) SetAmountInt(i int) {
	m.amount_int = &i
	m.addamount_int = nil
}

// AmountInt returns the value of the "amount_int" field in the mutation.
func (m *TransactionMutation) AmountInt() (r int, exists bool) {
	v := m.amount_int
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountInt returns the old "amount_int" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmountInt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmountInt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmountInt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountInt: %w", err)
	}
	return oldValue.AmountInt, nil
}

// AddAmountInt adds i to the "amount_int" field.
func (m *TransactionMutation) AddAmountInt(i int) {
	if m.addamount_int != nil {
		*m.addamount_int += i
	} else {
		m.addamount_int = &i
	}
}

// AddedAmountInt returns the value that was added to the "amount_int" field in this mutation.
func (m *TransactionMutation) AddedAmountInt() (r int, exists bool) {
	v := m.addamount_int
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountInt resets all changes to the "amount_int" field.
func (m *TransactionMutation) ResetAmountInt() {
	m.amount_int = nil
	m.addamount_int = nil
}

// SetAmountDigits sets the "amount_digits" field.
func (m *TransactionMutation) SetAmountDigits(i int) {
	m.amount_digits = &i
	m.addamount_digits = nil
}

// AmountDigits returns the value of the "amount_digits" field in the mutation.
func (m *TransactionMutation) AmountDigits() (r int, exists bool) {
	v := m.amount_digits
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountDigits returns the old "amount_digits" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmountDigits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmountDigits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmountDigits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountDigits: %w", err)
	}
	return oldValue.AmountDigits, nil
}

// AddAmountDigits adds i to the "amount_digits" field.
func (m *TransactionMutation) AddAmountDigits(i int) {
	if m.addamount_digits != nil {
		*m.addamount_digits += i
	} else {
		m.addamount_digits = &i
	}
}

// AddedAmountDigits returns the value that was added to the "amount_digits" field in this mutation.
func (m *TransactionMutation) AddedAmountDigits() (r int, exists bool) {
	v := m.addamount_digits
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountDigits resets all changes to the "amount_digits" field.
func (m *TransactionMutation) ResetAmountDigits() {
	m.amount_digits = nil
	m.addamount_digits = nil
}

// SetAddressFrom sets the "address_from" field.
func (m *TransactionMutation) SetAddressFrom(s string) {
	m.address_from = &s
}

// AddressFrom returns the value of the "address_from" field in the mutation.
func (m *TransactionMutation) AddressFrom() (r string, exists bool) {
	v := m.address_from
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressFrom returns the old "address_from" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAddressFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressFrom: %w", err)
	}
	return oldValue.AddressFrom, nil
}

// ResetAddressFrom resets all changes to the "address_from" field.
func (m *TransactionMutation) ResetAddressFrom() {
	m.address_from = nil
}

// SetAddressTo sets the "address_to" field.
func (m *TransactionMutation) SetAddressTo(s string) {
	m.address_to = &s
}

// AddressTo returns the value of the "address_to" field in the mutation.
func (m *TransactionMutation) AddressTo() (r string, exists bool) {
	v := m.address_to
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressTo returns the old "address_to" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAddressTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressTo: %w", err)
	}
	return oldValue.AddressTo, nil
}

// ResetAddressTo resets all changes to the "address_to" field.
func (m *TransactionMutation) ResetAddressTo() {
	m.address_to = nil
}

// SetNeedManualReview sets the "need_manual_review" field.
func (m *TransactionMutation) SetNeedManualReview(b bool) {
	m.need_manual_review = &b
}

// NeedManualReview returns the value of the "need_manual_review" field in the mutation.
func (m *TransactionMutation) NeedManualReview() (r bool, exists bool) {
	v := m.need_manual_review
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedManualReview returns the old "need_manual_review" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldNeedManualReview(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNeedManualReview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNeedManualReview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedManualReview: %w", err)
	}
	return oldValue.NeedManualReview, nil
}

// ResetNeedManualReview resets all changes to the "need_manual_review" field.
func (m *TransactionMutation) ResetNeedManualReview() {
	m.need_manual_review = nil
}

// SetType sets the "type" field.
func (m *TransactionMutation) SetType(t transaction.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransactionMutation) GetType() (r transaction.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldType(ctx context.Context) (v transaction.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransactionMutation) ResetType() {
	m._type = nil
}

// SetTransactionIDInsite sets the "transaction_id_insite" field.
func (m *TransactionMutation) SetTransactionIDInsite(s string) {
	m.transaction_id_insite = &s
}

// TransactionIDInsite returns the value of the "transaction_id_insite" field in the mutation.
func (m *TransactionMutation) TransactionIDInsite() (r string, exists bool) {
	v := m.transaction_id_insite
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionIDInsite returns the old "transaction_id_insite" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionIDInsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionIDInsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionIDInsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionIDInsite: %w", err)
	}
	return oldValue.TransactionIDInsite, nil
}

// ResetTransactionIDInsite resets all changes to the "transaction_id_insite" field.
func (m *TransactionMutation) ResetTransactionIDInsite() {
	m.transaction_id_insite = nil
}

// SetTransactionIDChain sets the "transaction_id_chain" field.
func (m *TransactionMutation) SetTransactionIDChain(s string) {
	m.transaction_id_chain = &s
}

// TransactionIDChain returns the value of the "transaction_id_chain" field in the mutation.
func (m *TransactionMutation) TransactionIDChain() (r string, exists bool) {
	v := m.transaction_id_chain
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionIDChain returns the old "transaction_id_chain" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransactionIDChain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionIDChain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionIDChain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionIDChain: %w", err)
	}
	return oldValue.TransactionIDChain, nil
}

// ResetTransactionIDChain resets all changes to the "transaction_id_chain" field.
func (m *TransactionMutation) ResetTransactionIDChain() {
	m.transaction_id_chain = nil
}

// SetStatus sets the "status" field.
func (m *TransactionMutation) SetStatus(t transaction.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TransactionMutation) Status() (r transaction.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldStatus(ctx context.Context) (v transaction.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransactionMutation) ResetStatus() {
	m.status = nil
}

// SetMutex sets the "mutex" field.
func (m *TransactionMutation) SetMutex(b bool) {
	m.mutex = &b
}

// Mutex returns the value of the "mutex" field in the mutation.
func (m *TransactionMutation) Mutex() (r bool, exists bool) {
	v := m.mutex
	if v == nil {
		return
	}
	return *v, true
}

// OldMutex returns the old "mutex" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldMutex(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMutex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMutex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMutex: %w", err)
	}
	return oldValue.Mutex, nil
}

// ResetMutex resets all changes to the "mutex" field.
func (m *TransactionMutation) ResetMutex() {
	m.mutex = nil
}

// SetCreatetimeUtc sets the "createtime_utc" field.
func (m *TransactionMutation) SetCreatetimeUtc(i int) {
	m.createtime_utc = &i
	m.addcreatetime_utc = nil
}

// CreatetimeUtc returns the value of the "createtime_utc" field in the mutation.
func (m *TransactionMutation) CreatetimeUtc() (r int, exists bool) {
	v := m.createtime_utc
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatetimeUtc returns the old "createtime_utc" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatetimeUtc(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatetimeUtc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatetimeUtc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatetimeUtc: %w", err)
	}
	return oldValue.CreatetimeUtc, nil
}

// AddCreatetimeUtc adds i to the "createtime_utc" field.
func (m *TransactionMutation) AddCreatetimeUtc(i int) {
	if m.addcreatetime_utc != nil {
		*m.addcreatetime_utc += i
	} else {
		m.addcreatetime_utc = &i
	}
}

// AddedCreatetimeUtc returns the value that was added to the "createtime_utc" field in this mutation.
func (m *TransactionMutation) AddedCreatetimeUtc() (r int, exists bool) {
	v := m.addcreatetime_utc
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatetimeUtc resets all changes to the "createtime_utc" field.
func (m *TransactionMutation) ResetCreatetimeUtc() {
	m.createtime_utc = nil
	m.addcreatetime_utc = nil
}

// SetUpdatetimeUtc sets the "updatetime_utc" field.
func (m *TransactionMutation) SetUpdatetimeUtc(i int) {
	m.updatetime_utc = &i
	m.addupdatetime_utc = nil
}

// UpdatetimeUtc returns the value of the "updatetime_utc" field in the mutation.
func (m *TransactionMutation) UpdatetimeUtc() (r int, exists bool) {
	v := m.updatetime_utc
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatetimeUtc returns the old "updatetime_utc" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatetimeUtc(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatetimeUtc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatetimeUtc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatetimeUtc: %w", err)
	}
	return oldValue.UpdatetimeUtc, nil
}

// AddUpdatetimeUtc adds i to the "updatetime_utc" field.
func (m *TransactionMutation) AddUpdatetimeUtc(i int) {
	if m.addupdatetime_utc != nil {
		*m.addupdatetime_utc += i
	} else {
		m.addupdatetime_utc = &i
	}
}

// AddedUpdatetimeUtc returns the value that was added to the "updatetime_utc" field in this mutation.
func (m *TransactionMutation) AddedUpdatetimeUtc() (r int, exists bool) {
	v := m.addupdatetime_utc
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatetimeUtc resets all changes to the "updatetime_utc" field.
func (m *TransactionMutation) ResetUpdatetimeUtc() {
	m.updatetime_utc = nil
	m.addupdatetime_utc = nil
}

// SetCoinID sets the "coin" edge to the CoinInfo entity by id.
func (m *TransactionMutation) SetCoinID(id int) {
	m.coin = &id
}

// ClearCoin clears the "coin" edge to the CoinInfo entity.
func (m *TransactionMutation) ClearCoin() {
	m.clearedcoin = true
}

// CoinCleared reports if the "coin" edge to the CoinInfo entity was cleared.
func (m *TransactionMutation) CoinCleared() bool {
	return m.clearedcoin
}

// CoinID returns the "coin" edge ID in the mutation.
func (m *TransactionMutation) CoinID() (id int, exists bool) {
	if m.coin != nil {
		return *m.coin, true
	}
	return
}

// CoinIDs returns the "coin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoinID instead. It exists only for internal usage by the builders.
func (m *TransactionMutation) CoinIDs() (ids []int) {
	if id := m.coin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoin resets all changes to the "coin" edge.
func (m *TransactionMutation) ResetCoin() {
	m.coin = nil
	m.clearedcoin = false
}

// AddReviewIDs adds the "review" edge to the Review entity by ids.
func (m *TransactionMutation) AddReviewIDs(ids ...int) {
	if m.review == nil {
		m.review = make(map[int]struct{})
	}
	for i := range ids {
		m.review[ids[i]] = struct{}{}
	}
}

// ClearReview clears the "review" edge to the Review entity.
func (m *TransactionMutation) ClearReview() {
	m.clearedreview = true
}

// ReviewCleared reports if the "review" edge to the Review entity was cleared.
func (m *TransactionMutation) ReviewCleared() bool {
	return m.clearedreview
}

// RemoveReviewIDs removes the "review" edge to the Review entity by IDs.
func (m *TransactionMutation) RemoveReviewIDs(ids ...int) {
	if m.removedreview == nil {
		m.removedreview = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.review, ids[i])
		m.removedreview[ids[i]] = struct{}{}
	}
}

// RemovedReview returns the removed IDs of the "review" edge to the Review entity.
func (m *TransactionMutation) RemovedReviewIDs() (ids []int) {
	for id := range m.removedreview {
		ids = append(ids, id)
	}
	return
}

// ReviewIDs returns the "review" edge IDs in the mutation.
func (m *TransactionMutation) ReviewIDs() (ids []int) {
	for id := range m.review {
		ids = append(ids, id)
	}
	return
}

// ResetReview resets all changes to the "review" edge.
func (m *TransactionMutation) ResetReview() {
	m.review = nil
	m.clearedreview = false
	m.removedreview = nil
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.amount_int != nil {
		fields = append(fields, transaction.FieldAmountInt)
	}
	if m.amount_digits != nil {
		fields = append(fields, transaction.FieldAmountDigits)
	}
	if m.address_from != nil {
		fields = append(fields, transaction.FieldAddressFrom)
	}
	if m.address_to != nil {
		fields = append(fields, transaction.FieldAddressTo)
	}
	if m.need_manual_review != nil {
		fields = append(fields, transaction.FieldNeedManualReview)
	}
	if m._type != nil {
		fields = append(fields, transaction.FieldType)
	}
	if m.transaction_id_insite != nil {
		fields = append(fields, transaction.FieldTransactionIDInsite)
	}
	if m.transaction_id_chain != nil {
		fields = append(fields, transaction.FieldTransactionIDChain)
	}
	if m.status != nil {
		fields = append(fields, transaction.FieldStatus)
	}
	if m.mutex != nil {
		fields = append(fields, transaction.FieldMutex)
	}
	if m.createtime_utc != nil {
		fields = append(fields, transaction.FieldCreatetimeUtc)
	}
	if m.updatetime_utc != nil {
		fields = append(fields, transaction.FieldUpdatetimeUtc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmountInt:
		return m.AmountInt()
	case transaction.FieldAmountDigits:
		return m.AmountDigits()
	case transaction.FieldAddressFrom:
		return m.AddressFrom()
	case transaction.FieldAddressTo:
		return m.AddressTo()
	case transaction.FieldNeedManualReview:
		return m.NeedManualReview()
	case transaction.FieldType:
		return m.GetType()
	case transaction.FieldTransactionIDInsite:
		return m.TransactionIDInsite()
	case transaction.FieldTransactionIDChain:
		return m.TransactionIDChain()
	case transaction.FieldStatus:
		return m.Status()
	case transaction.FieldMutex:
		return m.Mutex()
	case transaction.FieldCreatetimeUtc:
		return m.CreatetimeUtc()
	case transaction.FieldUpdatetimeUtc:
		return m.UpdatetimeUtc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldAmountInt:
		return m.OldAmountInt(ctx)
	case transaction.FieldAmountDigits:
		return m.OldAmountDigits(ctx)
	case transaction.FieldAddressFrom:
		return m.OldAddressFrom(ctx)
	case transaction.FieldAddressTo:
		return m.OldAddressTo(ctx)
	case transaction.FieldNeedManualReview:
		return m.OldNeedManualReview(ctx)
	case transaction.FieldType:
		return m.OldType(ctx)
	case transaction.FieldTransactionIDInsite:
		return m.OldTransactionIDInsite(ctx)
	case transaction.FieldTransactionIDChain:
		return m.OldTransactionIDChain(ctx)
	case transaction.FieldStatus:
		return m.OldStatus(ctx)
	case transaction.FieldMutex:
		return m.OldMutex(ctx)
	case transaction.FieldCreatetimeUtc:
		return m.OldCreatetimeUtc(ctx)
	case transaction.FieldUpdatetimeUtc:
		return m.OldUpdatetimeUtc(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmountInt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountInt(v)
		return nil
	case transaction.FieldAmountDigits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountDigits(v)
		return nil
	case transaction.FieldAddressFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressFrom(v)
		return nil
	case transaction.FieldAddressTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressTo(v)
		return nil
	case transaction.FieldNeedManualReview:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedManualReview(v)
		return nil
	case transaction.FieldType:
		v, ok := value.(transaction.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transaction.FieldTransactionIDInsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionIDInsite(v)
		return nil
	case transaction.FieldTransactionIDChain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionIDChain(v)
		return nil
	case transaction.FieldStatus:
		v, ok := value.(transaction.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transaction.FieldMutex:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMutex(v)
		return nil
	case transaction.FieldCreatetimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatetimeUtc(v)
		return nil
	case transaction.FieldUpdatetimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatetimeUtc(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount_int != nil {
		fields = append(fields, transaction.FieldAmountInt)
	}
	if m.addamount_digits != nil {
		fields = append(fields, transaction.FieldAmountDigits)
	}
	if m.addcreatetime_utc != nil {
		fields = append(fields, transaction.FieldCreatetimeUtc)
	}
	if m.addupdatetime_utc != nil {
		fields = append(fields, transaction.FieldUpdatetimeUtc)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmountInt:
		return m.AddedAmountInt()
	case transaction.FieldAmountDigits:
		return m.AddedAmountDigits()
	case transaction.FieldCreatetimeUtc:
		return m.AddedCreatetimeUtc()
	case transaction.FieldUpdatetimeUtc:
		return m.AddedUpdatetimeUtc()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmountInt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountInt(v)
		return nil
	case transaction.FieldAmountDigits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountDigits(v)
		return nil
	case transaction.FieldCreatetimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatetimeUtc(v)
		return nil
	case transaction.FieldUpdatetimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatetimeUtc(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldAmountInt:
		m.ResetAmountInt()
		return nil
	case transaction.FieldAmountDigits:
		m.ResetAmountDigits()
		return nil
	case transaction.FieldAddressFrom:
		m.ResetAddressFrom()
		return nil
	case transaction.FieldAddressTo:
		m.ResetAddressTo()
		return nil
	case transaction.FieldNeedManualReview:
		m.ResetNeedManualReview()
		return nil
	case transaction.FieldType:
		m.ResetType()
		return nil
	case transaction.FieldTransactionIDInsite:
		m.ResetTransactionIDInsite()
		return nil
	case transaction.FieldTransactionIDChain:
		m.ResetTransactionIDChain()
		return nil
	case transaction.FieldStatus:
		m.ResetStatus()
		return nil
	case transaction.FieldMutex:
		m.ResetMutex()
		return nil
	case transaction.FieldCreatetimeUtc:
		m.ResetCreatetimeUtc()
		return nil
	case transaction.FieldUpdatetimeUtc:
		m.ResetUpdatetimeUtc()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.coin != nil {
		edges = append(edges, transaction.EdgeCoin)
	}
	if m.review != nil {
		edges = append(edges, transaction.EdgeReview)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeCoin:
		if id := m.coin; id != nil {
			return []ent.Value{*id}
		}
	case transaction.EdgeReview:
		ids := make([]ent.Value, 0, len(m.review))
		for id := range m.review {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedreview != nil {
		edges = append(edges, transaction.EdgeReview)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transaction.EdgeReview:
		ids := make([]ent.Value, 0, len(m.removedreview))
		for id := range m.removedreview {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcoin {
		edges = append(edges, transaction.EdgeCoin)
	}
	if m.clearedreview {
		edges = append(edges, transaction.EdgeReview)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case transaction.EdgeCoin:
		return m.clearedcoin
	case transaction.EdgeReview:
		return m.clearedreview
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	switch name {
	case transaction.EdgeCoin:
		m.ClearCoin()
		return nil
	}
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	switch name {
	case transaction.EdgeCoin:
		m.ResetCoin()
		return nil
	case transaction.EdgeReview:
		m.ResetReview()
		return nil
	}
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// WalletNodeMutation represents an operation that mutates the WalletNode nodes in the graph.
type WalletNodeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	uuid                    *string
	location                *string
	host_vendor             *string
	public_ip               *string
	local_ip                *string
	createtime_utc          *int
	addcreatetime_utc       *int
	last_online_time_utc    *int
	addlast_online_time_utc *int
	clearedFields           map[string]struct{}
	coin                    *int
	clearedcoin             bool
	done                    bool
	oldValue                func(context.Context) (*WalletNode, error)
	predicates              []predicate.WalletNode
}

var _ ent.Mutation = (*WalletNodeMutation)(nil)

// walletnodeOption allows management of the mutation configuration using functional options.
type walletnodeOption func(*WalletNodeMutation)

// newWalletNodeMutation creates new mutation for the WalletNode entity.
func newWalletNodeMutation(c config, op Op, opts ...walletnodeOption) *WalletNodeMutation {
	m := &WalletNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeWalletNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWalletNodeID sets the ID field of the mutation.
func withWalletNodeID(id int) walletnodeOption {
	return func(m *WalletNodeMutation) {
		var (
			err   error
			once  sync.Once
			value *WalletNode
		)
		m.oldValue = func(ctx context.Context) (*WalletNode, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WalletNode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWalletNode sets the old WalletNode of the mutation.
func withWalletNode(node *WalletNode) walletnodeOption {
	return func(m *WalletNodeMutation) {
		m.oldValue = func(context.Context) (*WalletNode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WalletNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WalletNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WalletNodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the "uuid" field.
func (m *WalletNodeMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *WalletNodeMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the WalletNode entity.
// If the WalletNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletNodeMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *WalletNodeMutation) ResetUUID() {
	m.uuid = nil
}

// SetLocation sets the "location" field.
func (m *WalletNodeMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *WalletNodeMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the WalletNode entity.
// If the WalletNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletNodeMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *WalletNodeMutation) ResetLocation() {
	m.location = nil
}

// SetHostVendor sets the "host_vendor" field.
func (m *WalletNodeMutation) SetHostVendor(s string) {
	m.host_vendor = &s
}

// HostVendor returns the value of the "host_vendor" field in the mutation.
func (m *WalletNodeMutation) HostVendor() (r string, exists bool) {
	v := m.host_vendor
	if v == nil {
		return
	}
	return *v, true
}

// OldHostVendor returns the old "host_vendor" field's value of the WalletNode entity.
// If the WalletNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletNodeMutation) OldHostVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHostVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHostVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostVendor: %w", err)
	}
	return oldValue.HostVendor, nil
}

// ResetHostVendor resets all changes to the "host_vendor" field.
func (m *WalletNodeMutation) ResetHostVendor() {
	m.host_vendor = nil
}

// SetPublicIP sets the "public_ip" field.
func (m *WalletNodeMutation) SetPublicIP(s string) {
	m.public_ip = &s
}

// PublicIP returns the value of the "public_ip" field in the mutation.
func (m *WalletNodeMutation) PublicIP() (r string, exists bool) {
	v := m.public_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicIP returns the old "public_ip" field's value of the WalletNode entity.
// If the WalletNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletNodeMutation) OldPublicIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPublicIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPublicIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicIP: %w", err)
	}
	return oldValue.PublicIP, nil
}

// ResetPublicIP resets all changes to the "public_ip" field.
func (m *WalletNodeMutation) ResetPublicIP() {
	m.public_ip = nil
}

// SetLocalIP sets the "local_ip" field.
func (m *WalletNodeMutation) SetLocalIP(s string) {
	m.local_ip = &s
}

// LocalIP returns the value of the "local_ip" field in the mutation.
func (m *WalletNodeMutation) LocalIP() (r string, exists bool) {
	v := m.local_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalIP returns the old "local_ip" field's value of the WalletNode entity.
// If the WalletNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletNodeMutation) OldLocalIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocalIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocalIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalIP: %w", err)
	}
	return oldValue.LocalIP, nil
}

// ResetLocalIP resets all changes to the "local_ip" field.
func (m *WalletNodeMutation) ResetLocalIP() {
	m.local_ip = nil
}

// SetCreatetimeUtc sets the "createtime_utc" field.
func (m *WalletNodeMutation) SetCreatetimeUtc(i int) {
	m.createtime_utc = &i
	m.addcreatetime_utc = nil
}

// CreatetimeUtc returns the value of the "createtime_utc" field in the mutation.
func (m *WalletNodeMutation) CreatetimeUtc() (r int, exists bool) {
	v := m.createtime_utc
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatetimeUtc returns the old "createtime_utc" field's value of the WalletNode entity.
// If the WalletNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletNodeMutation) OldCreatetimeUtc(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatetimeUtc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatetimeUtc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatetimeUtc: %w", err)
	}
	return oldValue.CreatetimeUtc, nil
}

// AddCreatetimeUtc adds i to the "createtime_utc" field.
func (m *WalletNodeMutation) AddCreatetimeUtc(i int) {
	if m.addcreatetime_utc != nil {
		*m.addcreatetime_utc += i
	} else {
		m.addcreatetime_utc = &i
	}
}

// AddedCreatetimeUtc returns the value that was added to the "createtime_utc" field in this mutation.
func (m *WalletNodeMutation) AddedCreatetimeUtc() (r int, exists bool) {
	v := m.addcreatetime_utc
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatetimeUtc resets all changes to the "createtime_utc" field.
func (m *WalletNodeMutation) ResetCreatetimeUtc() {
	m.createtime_utc = nil
	m.addcreatetime_utc = nil
}

// SetLastOnlineTimeUtc sets the "last_online_time_utc" field.
func (m *WalletNodeMutation) SetLastOnlineTimeUtc(i int) {
	m.last_online_time_utc = &i
	m.addlast_online_time_utc = nil
}

// LastOnlineTimeUtc returns the value of the "last_online_time_utc" field in the mutation.
func (m *WalletNodeMutation) LastOnlineTimeUtc() (r int, exists bool) {
	v := m.last_online_time_utc
	if v == nil {
		return
	}
	return *v, true
}

// OldLastOnlineTimeUtc returns the old "last_online_time_utc" field's value of the WalletNode entity.
// If the WalletNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WalletNodeMutation) OldLastOnlineTimeUtc(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastOnlineTimeUtc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastOnlineTimeUtc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastOnlineTimeUtc: %w", err)
	}
	return oldValue.LastOnlineTimeUtc, nil
}

// AddLastOnlineTimeUtc adds i to the "last_online_time_utc" field.
func (m *WalletNodeMutation) AddLastOnlineTimeUtc(i int) {
	if m.addlast_online_time_utc != nil {
		*m.addlast_online_time_utc += i
	} else {
		m.addlast_online_time_utc = &i
	}
}

// AddedLastOnlineTimeUtc returns the value that was added to the "last_online_time_utc" field in this mutation.
func (m *WalletNodeMutation) AddedLastOnlineTimeUtc() (r int, exists bool) {
	v := m.addlast_online_time_utc
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastOnlineTimeUtc resets all changes to the "last_online_time_utc" field.
func (m *WalletNodeMutation) ResetLastOnlineTimeUtc() {
	m.last_online_time_utc = nil
	m.addlast_online_time_utc = nil
}

// SetCoinID sets the "coin" edge to the CoinInfo entity by id.
func (m *WalletNodeMutation) SetCoinID(id int) {
	m.coin = &id
}

// ClearCoin clears the "coin" edge to the CoinInfo entity.
func (m *WalletNodeMutation) ClearCoin() {
	m.clearedcoin = true
}

// CoinCleared reports if the "coin" edge to the CoinInfo entity was cleared.
func (m *WalletNodeMutation) CoinCleared() bool {
	return m.clearedcoin
}

// CoinID returns the "coin" edge ID in the mutation.
func (m *WalletNodeMutation) CoinID() (id int, exists bool) {
	if m.coin != nil {
		return *m.coin, true
	}
	return
}

// CoinIDs returns the "coin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CoinID instead. It exists only for internal usage by the builders.
func (m *WalletNodeMutation) CoinIDs() (ids []int) {
	if id := m.coin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCoin resets all changes to the "coin" edge.
func (m *WalletNodeMutation) ResetCoin() {
	m.coin = nil
	m.clearedcoin = false
}

// Where appends a list predicates to the WalletNodeMutation builder.
func (m *WalletNodeMutation) Where(ps ...predicate.WalletNode) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WalletNodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WalletNode).
func (m *WalletNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WalletNodeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.uuid != nil {
		fields = append(fields, walletnode.FieldUUID)
	}
	if m.location != nil {
		fields = append(fields, walletnode.FieldLocation)
	}
	if m.host_vendor != nil {
		fields = append(fields, walletnode.FieldHostVendor)
	}
	if m.public_ip != nil {
		fields = append(fields, walletnode.FieldPublicIP)
	}
	if m.local_ip != nil {
		fields = append(fields, walletnode.FieldLocalIP)
	}
	if m.createtime_utc != nil {
		fields = append(fields, walletnode.FieldCreatetimeUtc)
	}
	if m.last_online_time_utc != nil {
		fields = append(fields, walletnode.FieldLastOnlineTimeUtc)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WalletNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case walletnode.FieldUUID:
		return m.UUID()
	case walletnode.FieldLocation:
		return m.Location()
	case walletnode.FieldHostVendor:
		return m.HostVendor()
	case walletnode.FieldPublicIP:
		return m.PublicIP()
	case walletnode.FieldLocalIP:
		return m.LocalIP()
	case walletnode.FieldCreatetimeUtc:
		return m.CreatetimeUtc()
	case walletnode.FieldLastOnlineTimeUtc:
		return m.LastOnlineTimeUtc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WalletNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case walletnode.FieldUUID:
		return m.OldUUID(ctx)
	case walletnode.FieldLocation:
		return m.OldLocation(ctx)
	case walletnode.FieldHostVendor:
		return m.OldHostVendor(ctx)
	case walletnode.FieldPublicIP:
		return m.OldPublicIP(ctx)
	case walletnode.FieldLocalIP:
		return m.OldLocalIP(ctx)
	case walletnode.FieldCreatetimeUtc:
		return m.OldCreatetimeUtc(ctx)
	case walletnode.FieldLastOnlineTimeUtc:
		return m.OldLastOnlineTimeUtc(ctx)
	}
	return nil, fmt.Errorf("unknown WalletNode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case walletnode.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case walletnode.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case walletnode.FieldHostVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostVendor(v)
		return nil
	case walletnode.FieldPublicIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicIP(v)
		return nil
	case walletnode.FieldLocalIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalIP(v)
		return nil
	case walletnode.FieldCreatetimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatetimeUtc(v)
		return nil
	case walletnode.FieldLastOnlineTimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastOnlineTimeUtc(v)
		return nil
	}
	return fmt.Errorf("unknown WalletNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WalletNodeMutation) AddedFields() []string {
	var fields []string
	if m.addcreatetime_utc != nil {
		fields = append(fields, walletnode.FieldCreatetimeUtc)
	}
	if m.addlast_online_time_utc != nil {
		fields = append(fields, walletnode.FieldLastOnlineTimeUtc)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WalletNodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case walletnode.FieldCreatetimeUtc:
		return m.AddedCreatetimeUtc()
	case walletnode.FieldLastOnlineTimeUtc:
		return m.AddedLastOnlineTimeUtc()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WalletNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case walletnode.FieldCreatetimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatetimeUtc(v)
		return nil
	case walletnode.FieldLastOnlineTimeUtc:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastOnlineTimeUtc(v)
		return nil
	}
	return fmt.Errorf("unknown WalletNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WalletNodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WalletNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WalletNodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WalletNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WalletNodeMutation) ResetField(name string) error {
	switch name {
	case walletnode.FieldUUID:
		m.ResetUUID()
		return nil
	case walletnode.FieldLocation:
		m.ResetLocation()
		return nil
	case walletnode.FieldHostVendor:
		m.ResetHostVendor()
		return nil
	case walletnode.FieldPublicIP:
		m.ResetPublicIP()
		return nil
	case walletnode.FieldLocalIP:
		m.ResetLocalIP()
		return nil
	case walletnode.FieldCreatetimeUtc:
		m.ResetCreatetimeUtc()
		return nil
	case walletnode.FieldLastOnlineTimeUtc:
		m.ResetLastOnlineTimeUtc()
		return nil
	}
	return fmt.Errorf("unknown WalletNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WalletNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.coin != nil {
		edges = append(edges, walletnode.EdgeCoin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WalletNodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case walletnode.EdgeCoin:
		if id := m.coin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WalletNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WalletNodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WalletNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcoin {
		edges = append(edges, walletnode.EdgeCoin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WalletNodeMutation) EdgeCleared(name string) bool {
	switch name {
	case walletnode.EdgeCoin:
		return m.clearedcoin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WalletNodeMutation) ClearEdge(name string) error {
	switch name {
	case walletnode.EdgeCoin:
		m.ClearCoin()
		return nil
	}
	return fmt.Errorf("unknown WalletNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WalletNodeMutation) ResetEdge(name string) error {
	switch name {
	case walletnode.EdgeCoin:
		m.ResetCoin()
		return nil
	}
	return fmt.Errorf("unknown WalletNode edge %s", name)
}
